<details>
<summary>1. 프로세스 관리</summary>

---

### 프로세스란?

- 실행 중인 프로그램으로, 운영체제가 메모리와 CPU 같은 자원을 할당하여 관리하는 작업 단위  
- 메모리 내 여러 영역(코드, 데이터, 스택, 힙)으로 구성  
- 프로그램 실행 준비부터 종료까지 전 과정을 의미

---

### 프로세스 상태 및 생명주기

| 상태          | 설명                                             |
|-------------|------------------------------------------------|
| 새로 생성 (New)  | 프로세스가 생성되어 커널에 등록된 상태                       |
| 준비 (Ready)   | CPU 할당 대기 중, 모든 자원을 할당받은 상태                  |
| 실행 (Running) | CPU를 점유해 명령어를 수행 중인 상태                         |
| 대기 (Blocked) | I/O 등 이벤트를 기다려 CPU를 사용할 수 없는 상태               |
| 종료 (Terminated) | 프로세스 실행 종료, 자원 반납 완료 상태                     |

---

### 프로세스 제어 블록 (PCB)

- 프로세스 관리에 필요한 정보를 저장하는 데이터 구조  
- 내용: 프로세스 ID, 상태, 우선순위, 프로그램 카운터, 레지스터 값, 메모리 정보, 입출력 정보 등  
- CPU가 프로세스를 스케줄할 때 PCB 정보 참고

---

### 프로세스 생성과 종료

- 생성: 부모 프로세스에 의해 생성되며, 자식 프로세스는 부모의 자원 일부 공유 또는 복사  
- 종료: 작업 완료, 오류 발생, 외부 명령 등으로 프로세스 종료, 모든 자원 해제  

---

### 프로세스 스케줄링

- CPU 사용 권한을 프로세스들에 분배하는 작업  
- 스케줄링 알고리즘:  
  - FCFS (First Come First Serve)  
  - SJF (Shortest Job First)  
  - RR (Round Robin)  
  - 우선순위 기반 스케줄링 등  
- 목표: CPU 활용도 최대화, 공정성, 응답 시간 최소화

---

### 컨텍스트 스위칭 (Context Switching)

- CPU를 한 프로세스에서 다른 프로세스로 넘기는 작업  
- 현재 프로세스 상태(레지스터, 프로그램 카운터 등)를 PCB에 저장하고, 다음 프로세스 PCB에서 복원  
- 빈번한 문맥 교환은 오버헤드 발생, 성능 저하 원인

---

### 프로세스 간 동기화와 통신

- 동기화 문제: 경합, 데드락, 기아 현상 등  
- 해결책: 세마포어, 뮤텍스, 모니터 등 동기화 기법 사용  
- 통신방법: 파이프, 메시지 큐, 공유 메모리, 소켓, RPC 등 IPC 기법 포함

---

### 요약

프로세스 관리는
- 운영체제에서 가장 기본적이면서도 복잡한 영역 중 하나이며,  
- 효율적인 자원 관리와 사용자 응답성 향상을 위한 
- 핵심 메커니즘을 포함

---
</details>

---

<details>
<summary>2. 메모리 관리</summary>


---

### 메모리 관리의 중요성

- 프로세스 실행에 필요한 메모리를 적절히 할당하고 해제  
- 메모리 보호를 통해 프로세스 간 간섭 방지  
- 메모리 단편화 문제 해결과 효율적 자원 활용  

---

### 메모리 할당 방식

| 방식                     | 설명                                                      | 장점                             | 단점                             |
|------------------------|---------------------------------------------------------|--------------------------------|--------------------------------|
| 연속 할당 (Contiguous)          | 프로세스에 연속된 메모리 공간 할당                                     | 간단하고 빠름                      | 외부 단편화 발생, 컴팩션 필요           |
| 고정 분할 (Fixed Partition)     | 메모리를 고정 크기 파티션으로 나누어 할당                                | 구현 간단, 관리 쉬움                | 내부 단편화 발생, 비효율적               |
| 가변 분할 (Variable Partition)  | 프로세스 크기에 따라 가변 크기 할당                                     | 메모리 활용도 높음                  | 외부 단편화 발생, 관리 복잡               |
| 비연속 할당: 페이징 (Paging)     | 메모리를 동일 크기 프레임과 페이지로 나누어 할당                           | 외부 단편화 없음, 효율적 주소 변환     | 내부 단편화 존재, 페이지 테이블 오버헤드    |
| 세그멘테이션 (Segmentation)      | 논리적 의미 단위(코드, 데이터 등)로 분할해서 할당                          | 프로그래밍 친화적, 가변 크기 지원       | 외부 단편화 발생, 주소 변환 복잡             |

---

### 주소 변환 및 관리

- 논리 주소 → 페이지 번호 + 오프셋 → 물리 주소(프레임 번호 + 오프셋)  
- 페이지 테이블 및 다단계 페이지 테이블 구조 활용  
- 세그멘테이션 기반 주소 변환과 보호 비트 활용  

---

### 페이지 교체 알고리즘

- FIFO (First-In-First-Out)  
- LRU (Least Recently Used)  
- LFU (Least Frequently Used)  
- 최적 알고리즘(OPT) (이론적 기준)

---

### 단편화 문제 해결

- **내부 단편화**: 페이지 내 남는 공간 최소화 위해 페이지 크기 조정  
- **외부 단편화**: 컴팩션, 버디 시스템, 페이징과 세그멘테이션 혼합기법 사용  

---

### 가상 메모리

- 실제 RAM 부족 시 디스크 일부를 메모리처럼 사용  
- 페이지 폴트와 스와핑 방식  
- 워킹 셋과 스레싱 현상 방지

---

### 요약

메모리 관리는
- 운영체제의 핵심 기능으로,  
- 효율적이고 안정적 자원 활용과 프로세스 간 상호 간섭 방지를 위한 
- 다양한 기법과 알고리즘을 포함

</details>

---

<details>
<summary>3. 파일 시스템 관리</summary>

---

### 파일 시스템의 역할

- 운영체제가 저장장치 내 데이터를 효율적으로 저장, 관리, 검색할 수 있게 하는 구조와 규칙 집합  
- 사용자와 응용 프로그램이 데이터에 편리하게 접근하도록 지원

---

### 주요 기능

| 기능              | 설명                                            |
|-----------------|-----------------------------------------------|
| 파일 생성 및 삭제    | 파일과 디렉터리 생성, 삭제, 이름 변경 관리                |
| 데이터 읽기/쓰기    | 순차 접근과 임의 접근 등 다양한 접근 방식을 지원              |
| 메타데이터 관리    | 파일 이름, 크기, 권한, 생성/수정 시간 등 파일 특성 정보 관리     |
| 권한 및 보안 관리   | 사용자별, 그룹별 권한 설정과 접근 제어                    |
| 저장 공간 관리     | 디스크 블록 할당, 회수, 조각 모음                          |
| 파일 시스템 마운트/언마운트 | 다양한 파일 시스템을 운영체제에 연결 및 분리                  |

---

### 파일 할당 방법

- 연속 할당: 파일이 연속된 디스크 블록에 저장, 빠른 접근 가능하지만 외부 단편화 문제  
- 연결 할당: 파일이 디스크 블록 연결 리스트로 저장, 단편화 문제 완화  
- 인덱스 할당: 인덱스 블록에 디스크 위치 정보를 저장, 빠른 접근과 유연성 제공  

---

### 가상 파일 시스템 (VFS)

- 다양한 실제 파일 시스템을 추상화하여 통합된 인터페이스 제공  
- 응용 프로그램이 특정 파일 시스템에 독립적 접근 가능  
- 리눅스, 윈도우 등 주요 운영체제에 구현되어 다중 파일 시스템 지원  

---

### 파일 시스템 예시

- FAT, NTFS, ext3/ext4, XFS, ZFS 등 다양하며 각각 특징과 성능 차이 존재  
- 저널링, 트랜잭션 관리 등 데이터 무결성 보장 기술 포함  

---

### 디스크 스케줄링

- 입출력 요청을 효율적으로 처리하기 위한 스케줄링 알고리즘  
- FCFS, SSTF, SCAN, C-SCAN 등 다양하며 디스크 헤드 이동 최소화 목표  

---

### 요약

파일 시스템 관리는
- 운영체제가 데이터 저장 및 관리를 효율, 신뢰성, 보안성을 고려해 책임지는 중요한 영역이며,  
- 다양한 기법과 기술로 사용자 및 프로그램의 데이터 접근 편의와 
- 시스템 무결성을 지원

</details>

---

<details>
<summary>4. 네트워크와 소켓 프로그래밍</summary>


---

### 네트워크 개념

- 분산된 컴퓨터들이 데이터를 주고받기 위한 통신 인프라  
- TCP/IP, UDP를 포함한 다양한 프로토콜 스택 존재  
- OSI 7계층 모델 기반 통신 구조 이해 필요

---

### 소켓 프로그래밍

- 네트워크 통신을 위한 API로, 프로세스간 통신의 추상화  
- 소켓 종류:  
  - 스트림 소켓 (TCP, 연결지향, 신뢰성 보장)  
  - 데이터그램 소켓 (UDP, 비연결형, 빠르지만 신뢰성 낮음)  

---

### 고급 소켓 기술

- 논블로킹 소켓과 비동기 I/O  
- 멀티스레딩을 활용한 동시성 네트워크 처리  
- select(), poll(), epoll 같은 I/O 다중화 기술 활용  

---

### 네트워크 프로토콜 심화

- TCP: 신뢰성 있는 데이터 스트림 전송, 연결 설정/해제 과정 포함  
- UDP: 고속 비신뢰성 전송, 멀티캐스트 및 브로드캐스트 지원  
- HTTP, FTP, WebSocket 같은 응용계층 프로토콜 이해  

---

### 보안 통신

- SSL/TLS를 통한 데이터 암호화와 안전한 통신 경로 확보  
- 공개키 기반 인증과 디지털 서명  
- 방화벽 및 네트워크 접근제어 구현  

---

### 분산 시스템 네트워킹

- 서비스 디스커버리, 로드밸런싱 전략  
- 마이크로서비스와 컨테이너 네트워킹 (Docker, Kubernetes)  
- 클라우드 환경에서 네트워크 최적화  

---

### 예제: UDP 소켓 프로그래밍 (Python)

```python
import socket

# UDP 서버
server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server_socket.bind(('localhost', 12345))
print("UDP 서버 시작")

while True:
    data, addr = server_socket.recvfrom(1024)
    print(f"{addr} 로부터 받은 데이터: {data.decode()}")
    server_socket.sendto(data, addr)

```

---

### 요약

네트워크와 소켓 프로그래밍은
- 현대 분산 및 인터넷 응용 개발의 핵심이며,  
- 효율적인 데이터 전송과 보안, 동시성 제어가 필수적

---
</details>

---

<details>
<summary>5번 프로세스 간 통신 IPC</summary>

---

### IPC 개요

- 프로세스 간 데이터를 교환하여 협력 수행할 수 있도록 하는 운영체제 기능  
- 동기화 및 데이터 일관성 유지가 핵심 과제  

---

### IPC 방식 종류

| 방식           | 설명                                    | 특성                                  |
|--------------|---------------------------------------|-------------------------------------|
| 파이프 (Pipe)   | 부모-자식 또는 관계있는 프로세스 간 데이터 전송     | 단방향, 단순, 로컬 프로세스 간 통신                  |
| 명명 파이프 (Named Pipe) | 임의 프로세스 간 통신 가능, 파일 시스템에 이름 부여  | 양방향 가능, 네트워크 IPC 지원                      |
| 메시지 큐 (Message Queue) | 메시지를 큐에 저장하고 비동기 전송 가능            | 비동기, 우선순위 지정, 신뢰성 높음                   |
| 공유 메모리 (Shared Memory) | 프로세스가 메모리 영역을 직접 공유               | 매우 빠름, 동기화 메커니즘 필요                     |
| 소켓 (Socket)   | 네트워크 기반 프로세스 간 통신               | 로컬 & 원격 통신 모두 지원, TCP/UDP 프로토콜 사용 |

---

### 동기화 문제와 해결

- 교착 상태(Deadlock), 경쟁 조건(Race Condition) 발생 가능  
- 세마포어(Semaphore), 뮤텍스(Mutex), 모니터(Monitor)로 동기화 및 배타적 자원 관리  

---

### 원격 프로시저 호출 (RPC)

- 분산 시스템에서 다른 컴퓨터 프로세스의 함수를 호출하는 통신 방식  
- 호출자는 로컬 함수처럼 호출, 내부적으로 메시지 전송 및 응답 처리  
- 동기식과 비동기식 호출 지원  
- gRPC, Apache Thrift, JSON-RPC 등 현대적 RPC 프레임워크 존재  

---

### IPC 구현 고려 사항

- 메시지 큐 크기 제한 및 메시지 손실 방지  
- 공유 메모리 무결성 및 접근 권한 관리  
- 네트워크 지연과 오류 처리  
- 보안: 인증 및 암호화 필요  

---

### 요약

IPC는 
- 프로세스 협력과 데이터 공유의 기반이며,  
- 다양한 통신 메커니즘과 동기화 기법을 통해 
-  효율적인 운영체제 자원 관리에 필수적

---

</details>

---

<details>
<summary>6. 파일 시스템</summary>#

---

### 파일 시스템 역할

- 저장장치 내 데이터의 조직화, 저장, 접근, 보호를 담당  
- 사용자와 응용 프로그램이 데이터에 편리하게 접근하도록 지원  

---

### 파일 시스템 구성 요소

| 구성 요소       | 역할 및 설명                             |
|--------------|------------------------------------|
| 부트 블록 (Boot block)    | 부팅 정보와 부트 로더 코드 저장                  |
| 슈퍼블록 (Superblock)    | 파일시스템 전체 정보(크기, 상태 등) 저장           |
| 파일 제어 블록 (FCB)     | 파일의 메타데이터(소유자, 권한, 위치 등) 관리       |
| 디렉터리 구조          | 파일과 디렉터리의 논리적 계층 구조 구현             |
| 데이터 블록           | 파일의 실제 데이터 저장 공간                       |

---

### 파일 저장 및 할당 방법

- **연속 할당**: 파일이 디스크 상에 연속된 영역에 저장, 접근 속도 빠름, 외부 단편화 문제  
- **연결 할당**: 데이터 블록이 리스트 형태로 연결, 외부 단편화 해결, 직접 접근 느림  
- **인덱스 할당**: 인덱스 블록에 데이터 블록 주소 저장, 빠른 접근 및 유연성 제공

---

### 디렉터리 관리

- 단일 레벨부터 다중 레벨 트리 구조까지 다양  
- 경로명 (절대경로, 상대경로) 지원  
- 심볼릭 링크 및 하드 링크를 통한 다양한 참조 방식  

---

### 파일 접근법

- 순차적 접근: 전후 순서대로 데이터 처리  
- 직접 접근: 임의 위치로 바로 이동 가능  
- 색인 접근: 인덱스를 활용해 빠르게 데이터 검색  

---

### 파일 시스템 마운트 및 언마운트

- 파일 시스템을 OS에 연결(마운트) 하고 분리(언마운트) 함으로써 저장장치 관리 가능  
- 여러 파일 시스템 동시 지원 및 교체 가능

---

### 저장 공간 관리

- 블록 크기와 할당 정책에 따라 디스크 공간 관리  
- 조각 모음 (Defragmentation)으로 단편화 해소  
- 디스크 스케줄링과 캐싱으로 입출력 성능 향상

---

### 대표 파일 시스템 종류

- FAT, NTFS, ext3/ext4, XFS, ZFS 등 각기 특징과 적용 분야 별도

---

### 요약

파일 시스템은 
- 운영체제의 핵심 서브시스템으로 
- 데이터의 안정적 저장과 빠른 접근, 보호를 보장하며,  
- 다양한 기술과 구조로 대용량 저장장치 및 다중 사용자 환경을 지원

---

</details>

---

<details>
<summary>7. CPU 스케줄링</summary>

---

### 스케줄러 개요

- CPU를 여러 프로세스가 효율적으로 공유할 수 있도록 관리하는 운영체제 핵심 기능  
- 스케줄링 결정 시 프로세스 우선순위와 상태에 따라 CPU 할당  

---

### 스케줄링 분류

| 분류          | 설명                                   |
|-------------|--------------------------------------|
| 선점형 스케줄링    | 고우선순위 프로세스가 CPU 점유 중인 프로세스 강제 중단 가능        |
| 비선점형 스케줄링  | 프로세스가 종료하거나 대기 상태가 될 때까지 CPU 점유 유지          |

---

### 주요 스케줄링 알고리즘

| 알고리즘             | 분류   | 특징                                               | 장점                                     | 단점                                   |
|------------------|------|--------------------------------------------------|----------------------------------------|--------------------------------------|
| FCFS (First Come First Served) | 비선점 | 도착 순서대로 CPU 할당                                      | 구현 간단, 기아 없음                             | 긴 작업이 앞에 있으면 대기 시간이 길어짐               |
| SJF (Shortest Job First)      | 비선점 | 실행 시간이 가장 짧은 프로세스를 우선 실행                           | 평균 대기시간 최솟값                              | 실행 시간 예측 어려움, 기아 발생 가능                  |
| Round Robin (RR)             | 선점   | 일정 시간(퀀텀)마다 프로세스 교체                                   | 응답 시간 개선, 공평한 CPU 시간 분배                     | 퀀텀 시간 조절 어려움, 문맥 교환 오버헤드 발생               |
| 우선순위 스케줄링 (Priority)    | 선점/비선점 | 각 프로세스에 우선순위 부여, 높은 우선순위에 CPU 우선 할당                 | 중요도 기반 스케줄링 가능                            | 낮은 우선순위 프로세스 기아 현상                         |
| 다단계 큐 스케줄링 (Multi-Level Queue) | 선점   | 프로세스를 여러 큐로 분류, 큐별 다른 스케줄링 알고리즘 적용                    | 유형별 맞춤 스케줄링 가능                            | 큐 할당 및 관리 복잡                                   |
| 다단계 피드백 큐 (MLFQ)         | 선점   | 프로세스 우선순위를 동적으로 조정, 기아 현상 방지                            | 유연하고 효율적인 CPU 분배                           | 우선순위 조정 정책 설계 및 오버헤드 존재                    |

---

### 스케줄러 성능 지표

- 평균 대기 시간, 평균 반환 시간, CPU 활용도, 응답 시간  
- 기아 현상(Starvation) 방지 위한 에이징(Aging) 기법  

---

### 실시간 운영체제 스케줄링

- 고정 우선순위, 임계 구간 검사, 예약과 드릴다운 스케줄링 등  
- 프로세스 응답 시간 보장 필수

---

### 요약

CPU 스케줄링은 
- 운영체제 성능 결정의 핵심  
- 다양한 알고리즘으로 프로세스 특성 및 우선순위에 적합한 자원 배분 필요

---

</details>

---

<details>
<summary>8. 파일과 디렉터리</summary>

---

### 파일 시스템과 디렉터리 개념

- 파일 시스템은 파일과 디렉터리를 저장, 관리하는 운영체제의 핵심 서브시스템  
- 디렉터리는 파일과 다른 디렉터리를 포함하는 컨테이너(폴더)로 계층적 트리구조를 가짐  
- 최상위 루트 디렉터리부터 시작하여 하위 디렉터리가 분기되는 형태

---

### 디렉터리 구조 특징

- **트리 구조**: 각 노드가 파일 또는 디렉터리를 나타내며, 탐색과 관리에 효율적  
- **경로**: 특정 파일/디렉터리 위치를 나타내는 주소, 절대 경로와 상대 경로 존재  
- **링크**: 심볼릭 링크와 하드 링크로 파일/디렉터리를 참조하는 다양한 방법 제공

---

### 주요 디렉터리 및 파일 시스템 예시 (리눅스 기준)

| 디렉터리 경로 | 역할 및 내용                                      |
|-------------|------------------------------------------|
| /           | 루트 디렉터리, 모든 디렉터리와 파일의 시작점             |
| /bin        | 사용자 명령어 바이너리 저장                            |
| /etc        | 시스템 설정 파일 및 서비스 구성                       |
| /home       | 사용자 개인 홈 디렉터리                                |
| /usr        | 응용 프로그램과 라이브러리 저장                         |
| /var        | 로그, 캐시, 임시 파일 등 가변 데이터 저장                   |
| /dev        | 장치 파일 저장                                      |
| /proc       | 시스템 및 프로세스 정보 제공, 가상 파일 시스템                |

---

### 파일 시스템 내 디렉터리 관리

- 디렉터리는 특별한 파일 형태로 메타데이터와 하위 파일 리스트를 포함  
- 경로 탐색 시 디렉터리가 파일이나 하위 디렉터리를 참조하는 방식  
- 마운트 포인트를 통해 여러 파일 시스템을 단일 트리 구조로 통합  

---

### 경로 처리

- **절대 경로**: 루트부터 시작하여 전체 경로 지정  
- **상대 경로**: 현재 위치를 기준으로 경로 지정  
- 특수 디렉터리: `.`(현재 디렉터리), `..`(상위 디렉터리)

---

### 파일과 디렉터리 작업

- 생성, 삭제, 이름 변경, 이동  
- 권한 설정 및 접근 제어  
- 시스템콜(open, close, read, write, mkdir 등) 통해 구현

---

### 요약

파일과 디렉터리는 파일 시스템의 기본 단위이며,  
운영체제는 계층적 디렉터리 구조와 경로를 통해 사용자에게 직관적인 데이터 접근 및 관리를 제공한다.

---

</details>
